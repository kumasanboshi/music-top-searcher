# タスク規模判定ガイド

タスクの規模を判定し、適切なフローを選択することでコンテキスト消費を最適化します。

## 規模の定義

### S（小規模）: 1ファイル
- バグ修正
- テキスト・スタイル調整
- 既存関数の小さな修正
- コメント追加
- 影響範囲が明確で限定的

**例**:
- ボタンの色を変更
- 日付フォーマットのバグ修正
- 定数値の変更

### M（中規模）: 2-5ファイル
- 新規機能の一部実装
- リファクタリング
- 新規コンポーネント追加
- テストの追加が必要な変更

**例**:
- 新しいユーティリティ関数の追加
- 既存画面への機能追加
- カスタムフックの作成

### L（大規模）: 6ファイル以上
- 新規画面の実装
- アーキテクチャに関わる変更
- データモデルの変更
- 複数コンポーネントにまたがる機能
- 設計レビューが必要

**例**:
- 新規画面（Screen）の追加
- データベーススキーマの変更
- 状態管理の構造変更

## 規模判定フロー

```
1. 影響を受けるファイルを Grep/Glob で特定
2. import/依存関係を追跡
3. ファイル数をカウント
   - 1ファイル → S
   - 2-5ファイル → M
   - 6ファイル以上 → L
```

## 規模別実行フロー

### Sフロー（小規模）
```
1. 変更実施
2. 型チェック（npx tsc --noEmit）
3. コミット
```
**コンテキスト消費**: 最小

### Mフロー（中規模）
```
1. 影響範囲の確認
2. TodoWriteにステップ登録
3. テスト作成（TDD: RED）
4. 実装（TDD: GREEN）
5. リファクタリング（TDD: REFACTOR）
6. /quality-check 実行
7. コミット
```
**コンテキスト消費**: 中

### Lフロー（大規模）
```
1. /design-review で設計確認
2. タスク分解（各タスクをM以下に）
3. TodoWriteに全ステップ登録
4. 各タスクをMフローで実行
   - task-executor相当のサイクル
   - 完了ごとに進捗更新
5. 統合テスト
6. 最終 /quality-check 実行
7. コミット
```
**コンテキスト消費**: 大（ただし分割により管理可能）

## TodoWrite連携

### 規模判定後の必須アクション
規模判定が完了したら、以下をTodoWriteに登録:

**Sの場合**:
```
- [ ] 変更実施
- [ ] 型チェック
- [ ] コミット
```

**Mの場合**:
```
- [ ] 影響範囲確認
- [ ] テスト作成
- [ ] 実装
- [ ] 品質チェック
- [ ] コミット
```

**Lの場合**:
```
- [ ] 設計レビュー
- [ ] タスク分解
- [ ] タスク1: [内容]
- [ ] タスク2: [内容]
- [ ] ...
- [ ] 統合テスト
- [ ] 最終品質チェック
- [ ] コミット
```

## 規模昇格の判断

作業中に以下が発生した場合、規模を昇格:

| 発生事象 | アクション |
|---------|-----------|
| 想定外のファイル影響 | M→L に昇格、タスク分解 |
| 設計変更が必要 | 即座にエスカレーション |
| 新規依存関係の追加 | L に昇格、設計レビュー |

## コンテキスト節約のポイント

1. **小さく始める**: 最初はSと仮定し、必要に応じて昇格
2. **早期判定**: 着手前に必ず規模判定を実施
3. **分割統治**: Lタスクは必ずM以下に分解
4. **スキップ可能な手順**: Sでは設計レビュー・タスク分解をスキップ
